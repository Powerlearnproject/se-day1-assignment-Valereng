[![Open in Visual Studio Code](https://classroom.github.com/assets/open-in-vscode-2e0aaae1b6195c2367325f4f02e2d04e9abb55f0b24a779b69b11b9e10269abc.svg)](https://classroom.github.com/online_ide?assignment_repo_id=18418436&assignment_repo_type=AssignmentRepo)
# SE_Day1
Software Engineering Day1 Assignment

#Part 1: Introduction to Software Engineering

Explain what software engineering is and discuss its importance in the technology industry.
Answer 

Software engineering is the process of designing, developing, testing, deploying, and maintaining of software. It involves using structured methods, programming languages, tools, and frameworks to create reliable, scalable, and efficient software solutions.

The importance of software engineering to the technology industry is that it brings about technological Innovation in such a way thst AI, cloud computing, IoT, and blockchain all depend on software engineering. Engineers create the applications and platforms that enable new technologies to flourish. Software engineering is the architecture of the digital world. It translates ideas into tangible products and services, fueling innovation in the technology industry and across other industries. Technology industry rely on software to streamline operations, automate tasks, and improve efficiency

Identify and describe at least three key milestones in the evolution of software engineering.
Answer 
The Birth of Software Engineering (1968)
The term "software engineering" was first coined at the 1968 NATO Software Engineering Conference in response to the software crisis—a period when software projects were failing due to increasing complexity and lack of formal development methodologies. This milestone marked the beginning of software engineering as a discipline, emphasizing structured approaches to software development.


2. The Rise of Structured Programming (1970s-1980s)
In response to chaotic and unmanageable software development processes, structured programming emerged, popularized by figures like Edsger Dijkstra. Concepts such as modular design, top-down development, and control structures helped improve code readability and maintainability. The development of programming languages like C, Pascal, and Ada reflected these principles.


3. The Agile Manifesto and Modern Development Practices (2001-Present)
The early 2000s saw a shift from rigid, plan-driven methodologies (like Waterfall) to more flexible, iterative approaches. The Agile Manifesto, published in 2001, promoted principles such as continuous feedback, collaboration, and adaptability. This led to the widespread adoption of Scrum, Kanban, DevOps, and CI/CD, transforming how software is developed and deployed today.


List and briefly explain the phases of the Software Development Life Cycle.
Answer 
Planning – Defines the project scope, goals, resources, timeline, and feasibility to ensure a clear roadmap.


2. Requirement Analysis – Gathers and documents functional and non-functional requirements from stakeholders to determine what the software should do.


3. Design – Creates system architecture, UI/UX design, and database models, defining how the software will be structured and implemented.


4. Implementation (Coding) – Developers write the actual code based on the design specifications, following coding standards and best practices.


5. Testing – Verifies and validates the software through unit testing, integration testing, and system testing to identify and fix bugs.


6. Deployment – The software is released to production, ensuring smooth installation and configuration for end-users.


7. Maintenance & Support – Addresses bug fixes, performance improvements, and updates based on user feedback to keep the software functional and secure.





Compare and contrast the Waterfall and Agile methodologies. Provide examples of scenarios where each would be appropriate.
Answer
Testing: testing is performed at the end of the development cycle for waterfall while for Agile, testing is continuous in every interaction 

Flexibility: for waterfall rigid changes are difficult to implement while for Agile changes are accommodated easily

 Documentation: for waterfall there is comprehensive documentation before development starts while agile there is minimal documentation, focusing on working software 
 
Approach: for waterfall it is sequential and linear for agile it is iterative and incremental 

Delivery: for waterfall is delivers a complete product at the end while for agile it delivers in small increment throughout the project

When to Use Waterfall

1. Large-scale projects with well-defined requirements – e.g., government or enterprise applications where changes are minimal.

2. Regulated industries – e.g., healthcare or banking systems requiring extensive documentation and compliance.

3. Hardware and embedded systems – e.g., firmware development, where changes after implementation are costly.

Example: Building an air traffic control system, where all requirements must be strictly defined before development begins.


When to Use Agile

1. Projects with evolving requirements – e.g., startups or software products where user feedback influences features.

2. Fast-paced development environments – e.g., mobile apps or SaaS products needing frequent updates.

3. Cross-functional and collaborative teams – e.g., web development where designers, developers, and testers work together iteratively.

Example: Developing an e-commerce platform, where features like user experience and payment methods evolve based on customer feedback.


Describe the roles and responsibilities of a Software Developer, a Quality Assurance Engineer, and a Project Manager in a software engineering team.


Discuss the importance of Integrated Development Environments (IDEs) and Version Control Systems (VCS) in the software development process. Give examples of each.


What are some common challenges faced by software engineers? Provide strategies to overcome these challenges.


Explain the different types of testing (unit, integration, system, and acceptance) and their importance in software quality assurance.


#Part 2: Introduction to AI and Prompt Engineering


Define prompt engineering and discuss its importance in interacting with AI models.


Provide an example of a vague prompt and then improve it by making it clear, specific, and concise. Explain why the improved prompt is more effective.
